ARGUMENT 'distribution_file=SC2279/breseq/07_error_calibration/0.unique_only_coverage_distribution.tab' __ignored__

ARGUMENT 'plot_file=SC2279/breseq/output/calibration/0.unique_coverage.pdf' __ignored__

ARGUMENT 'deletion_propagation_pr_cutoff=0.000289143' __ignored__


R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-conda_cos6-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##
> ##
> ## AUTHORS
> ##
> ## Jeffrey E. Barrick <jeffrey.e.barrick@gmail.com>
> ##
> ## LICENSE AND COPYRIGHT
> ##
> ## Copyright (c) 2008-2010 Michigan State University
> ## Copyright (c) 2011-2017 The University of Texas at Austin
> ##
> ## breseq is free software; you can redistribute it and/or modify it under the
> ## terms the GNU General Public License as published by the Free Software
> ## Foundation; either version 1, or (at your option) any later version.
> ##
> ##
> 
> ## Arguments:
> ##   distribution_file=/path/to/input 
> ##   plot_file=/path/to/output 
> ##   deletion_propagation_pr_cutoff=float
> ##   plot_poisson=0 or 1
> ##   pdf_output=0 or 1
> 
> ## Returns these values printed out to output log
> ## 
> ##  1. print(nb_fit_size); # 0 if fit failed
> ##  2. print(nb_fit_mu);   # 0 if fit failed
> ##  3. print(m)q
> ##  4. print(v)
> ##  5. print(D)
> ##  6. print(deletion_propagation_coverage)
> ##     -1 if it was <1 after fitting (implying reference sequence is deleted)
> ##
> 
> plot_poisson = 0;
> pdf_output = 1;
> 
> this.print.level = 0
> #this.print.level = 2
> 
> for (e in commandArgs()) {
+   ta = strsplit(e,"=",fixed=TRUE)
+   if(! is.na(ta[[1]][2])) {
+     temp = ta[[1]][2]
+  #   temp = as.numeric(temp) #Im only inputting numbers so I added this to recognize scientific notation
+     if(substr(ta[[1]][1],nchar(ta[[1]][1]),nchar(ta[[1]][1])) == "I") {
+       temp = as.integer(temp)
+     }
+     if(substr(ta[[1]][1],nchar(ta[[1]][1]),nchar(ta[[1]][1])) == "N") {
+       temp = as.numeric(temp)
+     }
+     assign(ta[[1]][1],temp)
+     cat("assigned ",ta[[1]][1]," the value of |",temp,"|\n")
+   } else {
+     assign(ta[[1]][1],TRUE)
+     cat("assigned ",ta[[1]][1]," the value of TRUE\n")
+   }
+ }
assigned  /workspace/home/nasirja/covid-19-signal/.snakemake/conda/1f267c8dfdaa0356ebaad13adc66d00a/lib/R/bin/exec/R  the value of TRUE
assigned  --vanilla  the value of TRUE
assigned  distribution_file  the value of | SC2279/breseq/07_error_calibration/0.unique_only_coverage_distribution.tab |
assigned  plot_file  the value of | SC2279/breseq/output/calibration/0.unique_coverage.pdf |
assigned  deletion_propagation_pr_cutoff  the value of | 0.000289143 |
> 
> deletion_propagation_pr_cutoff = as.numeric(deletion_propagation_pr_cutoff);
> 
> ## initialize values to be filled in
> nb_fit_mu = 0
> nb_fit_size = 0
> m = 0
> v = 0
> D = 0
> deletion_propagation_coverage = -1
> 
> min_fraction_included_in_nb_fit = 0.01
> 
> #load data
> X<-read.table(distribution_file, header=T)
> 
> #table might be empty
> if (nrow(X) == 0)
+ {
+   #print out statistics
+   
+   print(nb_fit_size);
+   print(nb_fit_mu);
+   
+   print(m)
+   print(v)
+   print(D)
+   
+   print(deletion_propagation_coverage)
+   
+   q()
+ }
> 
> #create the distribution vector and fit
> Y<-rep(X$coverage, X$n)
> m<-mean(Y)
> v<-var(Y)
> D<-v/m
> 
> ###
> ## Smooth the distribution with a moving average window of size 5
> ## so that we can more reliably find it's maximum value
> ###
> 
> ma5 = c(1, 1, 1, 1, 1)/5;
> 
> ## filtering fails if there are too few points
> if (nrow(X) >= 5) {
+   X$ma = filter(X$n, ma5)
+ } else {
+ 	X$ma = X$n
+ }
> 
> i<-0
> max_n <- 0;
> min_i <- max( trunc(m/4), 1 ); #prevents zero for pathological distributions
> max_i <- i;
> for (i in min_i:length(X$ma))
+ {		
+   #cat(i, "\n")
+ 	if (!is.na(X$ma[i]) && (X$ma[i] > max_n))
+ 	{
+ 		max_n = X$ma[i];
+ 		max_i = i;
+ 	}
+ }
> 
> ##
> # Censor data on the right and left of the maximum
> ##
> 
> start_i = max(floor(max_i*0.5), 1);
> end_i = min(ceiling(max_i*1.5), length(X$ma));
> 
> if (start_i == end_i)
+ {
+   print(nb_fit_size);
+   print(nb_fit_mu);
+   
+   print(m)
+   print(v)
+   print(D)
+   
+   print(deletion_propagation_coverage)
+   
+   q()
+ }
> 
> cat("Fitting from coverage of ", start_i, " to ", end_i, ".\n", sep="")
Fitting from coverage of 1 to 5.
> 
> ##
> # Coarse grain so that we are only fitting a number of bins that is 1000-2000
> #
> # The later adjustment for doing the fits this way is to multiply the means
> # of the negative binomial and poisson distributions by the binning number.
> # (The size parameter of the negative binomial doesn't need to be adjusted.)
> ##
> 
> 
> num_per_bin = trunc((end_i - start_i) / 1000)
> 
> if (num_per_bin > 1) 
+ {
+   cat("Coarse-graining for fits\n")
+   start_i_for_fits = trunc(start_i/num_per_bin)
+   end_i_for_fits = ceiling(end_i/num_per_bin)
+   num_bins = end_i - start_i  + 1
+   cat("Fitting from coverage in adjusted bins ", start_i_for_fits, " to ", end_i_for_fits, ".\n", sep="")
+   cat("Number of bins ", num_bins, ". Each bin has ", num_per_bin, " coverage values.\n", sep="")
+ 
+   # Create a new vector where we've added together values in bins
+   X.for.fits = vector("double", end_i_for_fits)
+   for (i in start_i_for_fits:end_i_for_fits)
+   {
+     for (j in 1:num_per_bin)
+     {
+       if (i*num_per_bin+j <= length(X$n))
+       {
+         X.for.fits[i] = X.for.fits[i] + X$n[i*num_per_bin+j]
+       }
+     }
+   }
+ 
+ } else {
+   ## AVOID num_per_bin equalling zero!!
+   X.for.fits = X$n[1:end_i]
+   num_per_bin = 1
+   start_i_for_fits = start_i
+   end_i_for_fits = end_i
+ }
> 
> 
> ##
> # Now perform negative binomial fitting to the censored data
> ##
> 
> inner_total<-0;
> for (i in start_i_for_fits:end_i_for_fits)
+ {
+ 	inner_total = inner_total + X.for.fits[i]; 
+ }
> # Yes: it's correct to use X here because we want the overall total total
> total_total<-sum(X$n);
> 
> ## let's preconstruct these for speed
> dist = vector("double", end_i_for_fits)
> 
> f_nb <- function(par) {
+ 
+ 	mu = par[1];
+ 	size = par[2];
+ 
+   if ((mu <= 0) || (size <= 0))
+   {
+     return(0);
+   }
+   
+   cat(start_i_for_fits, " ", end_i_for_fits, "\n");
+   cat(mu, " ", size, "\n");
+   
+ 	dist<-c()
+ 	total <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{	
+ 		dist[i] <- dnbinom(i, size=size, mu=mu);
+ 		total <- total + dist[i] 
+ 	}
+ 	#print (mu, size)
+ 
+  	l <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{
+ 		l <- l + ((X.for.fits[i]/inner_total)-(dist[i]/total))^2;
+ 	}
+ 	return(l);
+ }
> 
> 
> 
> ## Fit negative binomial 
> ## - allow fit to fail and set all params to zero/empty if that is the case
> nb_fit = NULL
> ## as.numeric prevents overflow in sums involving integers
> mean_estimate = sum((as.numeric(1:end_i_for_fits)*as.numeric(X.for.fits)))/sum(as.numeric(X.for.fits))
> 
> nb_fit_mu = -1
> nb_fit_size = -1
> try_size = 100000
> try_means_index = 1
> #This is a list of different means to test <-  sometimes the actual mean doesn't lead to a fit
> try_means = c(mean_estimate, 
+               end_i_for_fits, 
+               start_i_for_fits, 
+               1*(end_i_for_fits + start_i_for_fits)/4,
+               2*(end_i_for_fits + start_i_for_fits)/4,
+               3*(end_i_for_fits + start_i_for_fits)/4
+               )
>               
>               
> nb_fit = c()
> 
> while ( ((nb_fit_mu < 0) || (nb_fit_size < 0) || (nb_fit$code != 1)) && (try_size > 0.001) && (try_means_index <= length(try_means)))
+ {
+   try_size = try_size / 10
+   try_mean = try_means[try_means_index]
+ 
+   ## SIZE ESTIMATE from the censored data can be negative, so try various values instead
+   cat("Try Mean: ", try_mean, " Size: ", try_size, "\n")
+ 
+   try( suppressWarnings(nb_fit<-nlm(f_nb, c(try_mean, try_size), iterlim=1000, print.level=this.print.level)) )
+ 
+   nb_fit_mu = nb_fit$estimate[1];
+   nb_fit_size = nb_fit$estimate[2];
+ 
+   cat("Fit Mean: ", nb_fit_mu, " Size: ", nb_fit_size, " Code: ", nb_fit$code, "\n")
+   
+   if (try_size <= 0.001) {
+     try_size = 100000
+     try_means_index = try_means_index + 1
+   }
+ }
Try Mean:  2.003119  Size:  10000 
1   5 
2.003119   10000 
1   5 
2.003119   10000 
1   5 
2.003121   10000 
1   5 
2.003119   10000.01 
1   5 
1.953476   10000 
1   5 
1.953478   10000 
1   5 
1.953476   10000.01 
1   5 
1.513882   10000 
1   5 
1.513884   10000 
1   5 
1.513882   10000.01 
1   5 
1.6551   10000 
1   5 
1.655102   10000 
1   5 
1.6551   10000.01 
1   5 
1.629082   10000 
1   5 
1.629083   10000 
1   5 
1.629082   10000.01 
1   5 
1.626791   10000 
1   5 
1.626793   10000 
1   5 
1.626791   10000.01 
1   5 
1.626837   10000 
1   5 
1.626839   10000 
1   5 
1.626837   10000.01 
1   5 
1.626837   10000 
1   5 
1.627   10000 
1   5 
1.626675   10000 
1   5 
1.626837   10001 
1   5 
1.626837   9999 
1   5 
1.626838   10000 
1   5 
1.627001   10000 
1   5 
1.626675   10000 
1   5 
1.626838   10001 
1   5 
1.626838   9999 
Fit Mean:  1.626838  Size:  10000  Code:  2 
Try Mean:  2.003119  Size:  1000 
1   5 
2.003119   1000 
1   5 
2.003119   1000 
1   5 
2.003121   1000 
1   5 
2.003119   1000.001 
1   5 
1.9536   1000 
1   5 
1.953602   1000 
1   5 
1.9536   1000.001 
1   5 
1.513807   1000 
1   5 
1.513808   1000 
1   5 
1.513807   1000.001 
1   5 
1.65527   1000 
1   5 
1.655271   1000 
1   5 
1.65527   1000.001 
1   5 
1.629181   1000 
1   5 
1.629183   1000 
1   5 
1.629181   1000.001 
1   5 
1.626877   1000 
1   5 
1.626879   1000 
1   5 
1.626877   1000.001 
1   5 
1.626924   1000 
1   5 
1.626926   1000 
1   5 
1.626924   1000.001 
1   5 
1.626924   1000 
1   5 
1.627087   1000 
1   5 
1.626761   1000 
1   5 
1.626924   1000.1 
1   5 
1.626924   999.9 
1   5 
1.626925   1000 
1   5 
1.627087   1000 
1   5 
1.626762   1000 
1   5 
1.626925   1000.1 
1   5 
1.626925   999.9 
Fit Mean:  1.626925  Size:  1000  Code:  2 
Try Mean:  2.003119  Size:  100 
1   5 
2.003119   100 
1   5 
2.003119   100 
1   5 
2.003121   100 
1   5 
2.003119   100.0001 
1   5 
1.954806   100 
1   5 
1.954808   100 
1   5 
1.954806   100.0001 
1   5 
1.51301   100 
1   5 
1.513012   100 
1   5 
1.51301   100.0001 
1   5 
1.656937   100 
1   5 
1.656939   100 
1   5 
1.656937   100.0001 
1   5 
1.630147   100 
1   5 
1.630148   100 
1   5 
1.630147   100.0001 
1   5 
1.627706   100.0001 
1   5 
1.627708   100.0001 
1   5 
1.627706   100.0002 
1   5 
1.627758   100.0001 
1   5 
1.62776   100.0001 
1   5 
1.627758   100.0002 
1   5 
1.62776   100.0001 
1   5 
1.627761   100.0001 
1   5 
1.62776   100.0002 
1   5 
1.627816   100.0009 
1   5 
1.627818   100.0009 
1   5 
1.627816   100.001 
1   5 
1.627874   100.0027 
1   5 
1.627876   100.0027 
1   5 
1.627874   100.0028 
1   5 
1.627988   100.0088 
1   5 
1.62799   100.0088 
1   5 
1.627988   100.0089 
1   5 
1.62816   100.0245 
1   5 
1.628162   100.0245 
1   5 
1.62816   100.0246 
1   5 
1.628446   100.068 
1   5 
1.628448   100.068 
1   5 
1.628446   100.0681 
1   5 
1.628902   100.1825 
1   5 
1.628903   100.1825 
1   5 
1.628902   100.1826 
1   5 
1.629634   100.4855 
1   5 
1.629636   100.4855 
1   5 
1.629634   100.4856 
1   5 
1.630788   101.2734 
1   5 
1.63079   101.2734 
1   5 
1.630788   101.2735 
1   5 
1.63254   103.2834 
1   5 
1.632541   103.2834 
1   5 
1.63254   103.2835 
1   5 
1.634957   108.1941 
1   5 
1.634958   108.1941 
1   5 
1.634957   108.1942 
1   5 
1.637627   119.3417 
1   5 
1.637629   119.3417 
1   5 
1.637627   119.3419 
1   5 
1.639156   142.5062 
1   5 
1.639157   142.5062 
1   5 
1.639156   142.5063 
1   5 
1.637151   186.3428 
1   5 
1.637152   186.3428 
1   5 
1.637151   186.3429 
1   5 
1.631037   253.2832 
1   5 
1.631038   253.2832 
1   5 
1.631037   253.2835 
1   5 
1.625678   324.1578 
1   5 
1.62568   324.1578 
1   5 
1.625678   324.1581 
1   5 
1.623269   389.54 
1   5 
1.623271   389.54 
1   5 
1.623269   389.5404 
1   5 
1.622438   484.5047 
1   5 
1.62244   484.5047 
1   5 
1.622438   484.5051 
1   5 
1.623525   640.0637 
1   5 
1.623526   640.0637 
1   5 
1.623525   640.0643 
1   5 
1.62594   854.8245 
1   5 
1.625942   854.8245 
1   5 
1.62594   854.8254 
1   5 
1.627814   1097.739 
1   5 
1.627816   1097.739 
1   5 
1.627814   1097.74 
1   5 
1.628664   1383.546 
1   5 
1.628666   1383.546 
1   5 
1.628664   1383.548 
1   5 
1.628624   1800.369 
1   5 
1.628626   1800.369 
1   5 
1.628624   1800.371 
1   5 
1.627778   2403.565 
1   5 
1.62778   2403.565 
1   5 
1.627778   2403.568 
1   5 
1.626775   3168.908 
1   5 
1.626776   3168.908 
1   5 
1.626775   3168.912 
1   5 
1.626163   4075.737 
1   5 
1.626164   4075.737 
1   5 
1.626163   4075.741 
1   5 
1.625998   5277.13 
1   5 
1.626   5277.13 
1   5 
1.625998   5277.135 
1   5 
1.626247   6988.261 
1   5 
1.626248   6988.261 
1   5 
1.626247   6988.268 
1   5 
1.626705   9325.638 
1   5 
1.626707   9325.638 
1   5 
1.626705   9325.648 
1   5 
1.627053   12095.4 
1   5 
1.627055   12095.4 
1   5 
1.627053   12095.41 
1   5 
1.627219   15890.12 
1   5 
1.627221   15890.12 
1   5 
1.627219   15890.14 
1   5 
1.627161   20583.99 
1   5 
1.627162   20583.99 
1   5 
1.627161   20584.01 
1   5 
1.626959   27641.01 
1   5 
1.626961   27641.01 
1   5 
1.626959   27641.04 
1   5 
1.626781   35396.06 
1   5 
1.626783   35396.06 
1   5 
1.626781   35396.1 
1   5 
1.626621   49792.79 
1   5 
1.626623   49792.79 
1   5 
1.626621   49792.84 
1   5 
1.626616   65115.97 
1   5 
1.626618   65115.97 
1   5 
1.626616   65116.04 
1   5 
1.626709   87359.86 
1   5 
1.626711   87359.86 
1   5 
1.626709   87359.95 
1   5 
1.626794   100102.4 
1   5 
1.626795   100102.4 
1   5 
1.626794   100102.5 
1   5 
1.626959   140757.7 
1   5 
1.62696   140757.7 
1   5 
1.626959   140757.8 
1   5 
1.626985   163647.6 
1   5 
1.626987   163647.6 
1   5 
1.626985   163647.7 
1   5 
1.626901   151514.1 
1   5 
1.626956   159385.4 
1   5 
1.626976   162317.7 
1   5 
1.626982   163216.7 
1   5 
1.626984   163508 
1   5 
1.626985   163602.3 
1   5 
1.626985   163632.9 
1   5 
1.626985   163642.8 
1   5 
1.626985   163646 
1   5 
1.626985   163647.1 
1   5 
1.626985   163647.4 
1   5 
1.626987   163647.4 
1   5 
1.626985   163647.6 
Fit Mean:  1.626985  Size:  163647.4  Code:  2 
Try Mean:  2.003119  Size:  10 
1   5 
2.003119   10 
1   5 
2.003119   10 
1   5 
2.003121   10 
1   5 
2.003119   10.00001 
1   5 
1.964639   9.999965 
1   5 
1.964641   9.999965 
1   5 
1.964639   9.999975 
1   5 
1.502083   10.00477 
1   5 
1.502084   10.00477 
1   5 
1.502083   10.00478 
1   5 
1.671613   10.00413 
1   5 
1.671614   10.00413 
1   5 
1.671613   10.00414 
1   5 
1.637556   10.00615 
1   5 
1.637557   10.00615 
1   5 
1.637556   10.00616 
1   5 
1.633353   10.00839 
1   5 
1.633355   10.00839 
1   5 
1.633353   10.0084 
1   5 
1.63297   10.01082 
1   5 
1.632971   10.01082 
1   5 
1.63297   10.01083 
1   5 
1.626726   10.08929 
1   5 
1.626728   10.08929 
1   5 
1.626726   10.0893 
1   5 
1.620514   10.24638 
1   5 
1.620516   10.24638 
1   5 
1.620514   10.24639 
1   5 
1.610108   10.74051 
1   5 
1.61011   10.74051 
1   5 
1.610108   10.74052 
1   5 
1.599579   11.82224 
1   5 
1.59958   11.82224 
1   5 
1.599579   11.82225 
1   5 
1.593717   14.14668 
1   5 
1.593718   14.14668 
1   5 
1.593717   14.14669 
1   5 
1.601961   18.4654 
1   5 
1.601962   18.4654 
1   5 
1.601961   18.46542 
1   5 
1.622344   24.62773 
1   5 
1.622346   24.62773 
1   5 
1.622344   24.62775 
1   5 
1.6363   30.88564 
1   5 
1.636302   30.88564 
1   5 
1.6363   30.88567 
1   5 
1.641829   37.78501 
1   5 
1.641831   37.78501 
1   5 
1.641829   37.78505 
1   5 
1.641089   48.59421 
1   5 
1.641091   48.59421 
1   5 
1.641089   48.59426 
1   5 
1.63407   64.74461 
1   5 
1.634072   64.74461 
1   5 
1.63407   64.74468 
1   5 
1.62647   84.64067 
1   5 
1.626472   84.64067 
1   5 
1.62647   84.64075 
1   5 
1.622456   107.194 
1   5 
1.622458   107.194 
1   5 
1.622456   107.1941 
1   5 
1.621703   138.1075 
1   5 
1.621705   138.1075 
1   5 
1.621703   138.1076 
1   5 
1.623848   182.9307 
1   5 
1.62385   182.9307 
1   5 
1.623848   182.9309 
1   5 
1.626904   241.3495 
1   5 
1.626906   241.3495 
1   5 
1.626904   241.3498 
1   5 
1.628867   312.9986 
1   5 
1.628869   312.9986 
1   5 
1.628867   312.9989 
1   5 
1.629352   407.8071 
1   5 
1.629354   407.8071 
1   5 
1.629352   407.8075 
1   5 
1.628548   540.277 
1   5 
1.62855   540.277 
1   5 
1.628548   540.2776 
1   5 
1.627202   716.3405 
1   5 
1.627203   716.3405 
1   5 
1.627202   716.3412 
1   5 
1.626191   939.2085 
1   5 
1.626192   939.2085 
1   5 
1.626191   939.2095 
1   5 
1.625835   1230.276 
1   5 
1.625837   1230.276 
1   5 
1.625835   1230.277 
1   5 
1.626084   1627.427 
1   5 
1.626085   1627.427 
1   5 
1.626084   1627.429 
1   5 
1.626636   2157.923 
1   5 
1.626637   2157.923 
1   5 
1.626636   2157.925 
1   5 
1.627105   2843.741 
1   5 
1.627107   2843.741 
1   5 
1.627105   2843.744 
1   5 
1.627299   3740.028 
1   5 
1.627301   3740.028 
1   5 
1.627299   3740.032 
1   5 
1.627215   4946.388 
1   5 
1.627216   4946.388 
1   5 
1.627215   4946.393 
1   5 
1.626973   6560.992 
1   5 
1.626975   6560.992 
1   5 
1.626973   6560.998 
1   5 
1.626745   8669.172 
1   5 
1.626747   8669.172 
1   5 
1.626745   8669.181 
1   5 
1.626634   11417.08 
1   5 
1.626635   11417.08 
1   5 
1.626634   11417.09 
1   5 
1.626652   15093.86 
1   5 
1.626653   15093.86 
1   5 
1.626652   15093.88 
1   5 
1.626751   19691.24 
1   5 
1.626752   19691.24 
1   5 
1.626751   19691.26 
1   5 
1.626868   26795.75 
1   5 
1.626869   26795.75 
1   5 
1.626868   26795.77 
1   5 
1.626906   33426.81 
1   5 
1.626908   33426.81 
1   5 
1.626906   33426.85 
1   5 
1.626923   43625.47 
1   5 
1.626925   43625.47 
1   5 
1.626923   43625.51 
1   5 
1.626884   50523.19 
1   5 
1.626886   50523.19 
1   5 
1.626884   50523.24 
1   5 
1.626864   57950.13 
1   5 
1.626866   57950.13 
1   5 
1.626864   57950.19 
1   5 
1.626838   68148.79 
1   5 
1.62684   68148.79 
1   5 
1.626838   68148.85 
1   5 
1.626821   78347.44 
1   5 
1.626823   78347.44 
1   5 
1.626821   78347.51 
1   5 
1.626811   88546.09 
1   5 
1.626812   88546.09 
1   5 
1.626811   88546.18 
1   5 
1.626803   98744.74 
1   5 
1.626804   98744.74 
1   5 
1.626803   98744.84 
1   5 
1.626813   103651.1 
1   5 
1.626815   103651.1 
1   5 
1.626813   103651.2 
1   5 
1.626816   113849.7 
1   5 
1.626818   113849.7 
1   5 
1.626816   113849.9 
1   5 
1.626822   114881.4 
1   5 
1.626824   114881.4 
1   5 
1.626822   114881.5 
1   5 
1.626826   121455.2 
1   5 
1.626828   121455.2 
1   5 
1.626826   121455.3 
Fit Mean:  1.626826  Size:  121455.2  Code:  1 
> 
> cat("Final Fit Mean: ", nb_fit_mu, " Size: ", nb_fit_size, " Code: ", nb_fit$code, " Try Size: ", try_size, "\n")
Final Fit Mean:  1.626826  Size:  121455.2  Code:  1  Try Size:  10 
> 
> ## Fit failed = reset parameters so graphing and output code can recognize this
> if ((nb_fit_mu < 0) || (nb_fit_size < 0) || (nb_fit$code != 1))
+ {
+   nb_fit_mu = 0
+   nb_fit_size = 0
+ }
> 
> 
> ## things can go wrong with fitting and we can still end up with invalid values
> 
> fit_nb = c()
> included_fract = 0
> if (nb_fit_mu > 0)
+ {
+   end_fract = pnbinom(end_i_for_fits, mu = nb_fit_mu, size=nb_fit_size)
+   start_fract = pnbinom(start_i_for_fits, mu = nb_fit_mu, size=nb_fit_size)
+   included_fract = end_fract-start_fract;
+ 
+   if (included_fract >= 0.01) {
+ 
+     ## Adjust so that we are back in full coords before making fit!!
+     if (num_per_bin > 1) 
+     {
+       nb_fit_mu = nb_fit_mu * num_per_bin
+     }
+     fit_nb = dnbinom(0:max(X$coverage), mu = nb_fit_mu, size=nb_fit_size)*inner_total/included_fract;
+   }
+ }
> 
> ## If an insufficient amount of fit was included, then invalidate it
> if (included_fract < 0.01)
+ {
+   nb_fit_mu = 0
+   nb_fit_size = 0
+ }
> 
> f_p <- function(par) {
+ 
+   lambda = par[1];
+ 
+   if (lambda <= 0)
+   {
+     return(0);
+   }
+   
+ 	total <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{	
+     #cat(i, " ", lambda, "\n");
+ 		dist[i] <- dpois(i, lambda=lambda);
+ 		total <- total + dist[i] 
+ 	}
+ 	#print (total)
+ 
+  	l <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{
+ 		l <- l + ((X.for.fits[i]/inner_total)-(dist[i]/total))^2;
+ 	}
+ 	return(l);
+ }
> 
> 
> ## Fit Poisson 
> ## - allow fit to fail and set all params to zero/empty if that is the case
> 
> p_fit = NULL
> try(suppressWarnings(p_fit<-nlm(f_p, c(m), print.level=this.print.level)))
> 
> fit_p = c()
> if (!is.null(p_fit) && (p_fit$estimate[1] > 0))
+ {
+   #print (nb_fit$estimate[1])
+   p_fit_lambda = p_fit$estimate[1];
+   #print(0:max(X$coverage))
+ 
+   end_fract = ppois(end_i_for_fits, lambda = p_fit_lambda)
+   start_fract = ppois(start_i_for_fits, lambda = p_fit_lambda)
+   included_fract = end_fract-start_fract;
+ 
+   ## Adjust so that we are back in full coords before making fit!!
+   if (num_per_bin > 1) 
+   {
+     p_fit_lambda = p_fit_lambda * num_per_bin
+   }
+   fit_p<-dpois(0:max(X$coverage), lambda = p_fit_lambda)*inner_total/included_fract;
+ }
> 
> 
> ## Graphing
> ##
> ## don't graph very high values with very little coverage
> i<-max_i
> while (i <= length(X$n) && X$n[i]>0.01*max_n)
+ {		
+ 	i <- i+1;
+ }
> graph_end_i <-i
> 
> ## Ths leaves enough room to the right of the peak for the legend
> graph_end_i = max(floor(2.2 * max_i), graph_end_i);
> 
> ## graphics settings
> my_pch = 21
> my_col = "black";
> my_col_censored = "red";
> 
> if (pdf_output == 0) {
+   
+   ## bitmap() requires ghostscript to be installed.
+   ## taa=4, gaa=2 options NOT compatible with earlier R versions!
+   ## units = "px" NOT compatible with even earlier R versions!
+   
+   if(!capabilities(what = "png"))
+   {
+     ## fallback to ghostscript
+     bitmap(plot_file, height=6, width=7, type = "png16m", res = 72, pointsize=18)
+   } else {
+     ## use X11 function, which gives better resolution
+     png(plot_file, height=6, width=7, units ="in", res = 72, pointsize=18)
+     par(family="sans")
+   }
+ } else {
+   pdf(plot_file, height=6, width=7)
+   par(family="sans")
+ }
> 
> par(mar=c(5.5,7.5,3,1.5));
> 
> max_y = 0
> if (plot_poisson) {
+ 	max_y = max(X$n, fit_p, fit_nb)
+ } else {
+ 	max_y = max(X$n, fit_nb)
+ }
> 
> plot(0:10, 0:10, type="n", lty="solid", ylim=c(0, max_y)*1.05, xlim=c(0, graph_end_i), lwd=1, xaxs="i", yaxs="i", axes=F, las=1, main="Coverage Distribution at Unique-Only Positions", xlab="Coverage depth (reads)", ylab="", cex.lab=1.2, cex.axis=1.2)
> 
> mtext(side = 2, text = "Number of reference positions", line = 5.5, cex=1.2)
> 
> sciNotation <- function(x, digits = 1) {
+     if (length(x) > 1) {
+         return(append(sciNotation(x[1]), sciNotation(x[-1])))     
+ 	} 
+     if (!x) return(0) 
+ 
+ 	exponent <- floor(log10(x)) 
+     base <- round(x / 10^exponent, digits)     
+ 	as.expression(substitute(base %*% 10^exponent, list(base = base, exponent = exponent))) 
+ }
> 
> #axis(2, cex.lab=1.2, las=1, cex.axis=1.2, labels=T, at=(0:6)*50000)
> axis(2, cex.lab=1.2, las=1, cex.axis=1.2, at = axTicks(2), labels = sciNotation(axTicks(2), 1))
> axis(1, cex.lab=1.2, cex.axis=1.2, labels=T)
> box()
> 
> #graph the coverage as points
> fit_data <- subset(X, (coverage>=start_i) & (coverage<=end_i) );
> points(fit_data$coverage, fit_data$n, pch=my_pch, col=my_col, bg="white", cex=1.2)
> 
> #graph the censored coverage as red points
> cat(start_i, " ", end_i, "\n", sep="")
1 5
> 
> censored_data <- subset(X, (coverage<start_i) | (coverage>end_i) );
> points(censored_data$coverage, censored_data$n, pch=my_pch, col=my_col_censored, bg="white", cex=1.2)
> 
> #graph the poisson fit IF REQUESTED
> if (plot_poisson) {
+ 	lines(0:max(X$coverage), fit_p, lwd=3, lty="22", col="black");
+ }
> 
> #graph the negative binomial fit
> if (nb_fit_mu > 0) {
+   lines(0:max(X$coverage), fit_nb, lwd=3, col="black");
+ }
> 
> if (plot_poisson) {
+ 	legend("topright", c("Coverage distribution", "Censored data", "Negative binomial", "Poisson"), lty=c("blank","blank","solid","22"), lwd=c(1,1,2,2), pch=c(my_pch, my_pch, -1, -1), col=c("black", "red", "black", "black"), bty="n")
+ } else {
+ 	legend("topright", c("Coverage distribution", "Censored data", "Negative binomial"), lty=c("blank","blank","solid"), lwd=c(1,1,2), pch=c(my_pch, my_pch, -1), col=c("black", "red", "black"), bty="n")
+ }
> 
> dev.off()
null device 
          1 
> 
> ## Fit the marginal value that we use for propagating deletions
> 
> if (nb_fit_mu > 0) {
+   cat(nb_fit_size, " ", nb_fit_mu, "\n")
+   deletion_propagation_coverage = suppressWarnings(qnbinom(deletion_propagation_pr_cutoff, size = nb_fit_size, mu = nb_fit_mu))
+ } else {
+   cat("Fallback to calculating off an estimate of just variance = mu + mu^2/size\n")
+   size_estimate = (1/(v-m))*(m*m)
+   cat("Mu estimate=", m," Size estimate =", size_estimate, "\n")
+   deletion_propagation_coverage = suppressWarnings(qnbinom(deletion_propagation_pr_cutoff, size = size_estimate, mu = m))
+   if (is.na(deletion_propagation_coverage) || is.nan(deletion_propagation_coverage) || (deletion_propagation_coverage < 1)) {
+     cat("Double fallback to calculating as just 10% of the mean\n")
+     deletion_propagation_coverage = m * 0.1
+   }
+ }
121455.2   1.626826 
> 
> #Don't allow one read to indicate non-deleted regions
> if (deletion_propagation_coverage < 1) {
+     deletion_propagation_coverage = 1
+ }
> 
> #This works fine with the negative values
> #If we have both low fit coverage and low straight average coverage then we're deleted...
> if ( (nb_fit_mu <= 3) && (m <= 3) ) {
+   deletion_propagation_coverage = -1
+ }
> 
> #print out statistics
> 
> print(nb_fit_size);
[1] 121455.2
> print(nb_fit_mu);
[1] 1.626826
> 
> print(m)
[1] 2.380433
> print(v)
[1] 4.909143
> print(D)
[1] 2.06229
> 
> print(deletion_propagation_coverage)
[1] -1
> 
> warnings()
> 
