ARGUMENT 'distribution_file=Plate3BLANK2/breseq/07_error_calibration/0.unique_only_coverage_distribution.tab' __ignored__

ARGUMENT 'plot_file=Plate3BLANK2/breseq/output/calibration/0.unique_coverage.pdf' __ignored__

ARGUMENT 'deletion_propagation_pr_cutoff=0.000289143' __ignored__


R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-conda_cos6-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##
> ##
> ## AUTHORS
> ##
> ## Jeffrey E. Barrick <jeffrey.e.barrick@gmail.com>
> ##
> ## LICENSE AND COPYRIGHT
> ##
> ## Copyright (c) 2008-2010 Michigan State University
> ## Copyright (c) 2011-2017 The University of Texas at Austin
> ##
> ## breseq is free software; you can redistribute it and/or modify it under the
> ## terms the GNU General Public License as published by the Free Software
> ## Foundation; either version 1, or (at your option) any later version.
> ##
> ##
> 
> ## Arguments:
> ##   distribution_file=/path/to/input 
> ##   plot_file=/path/to/output 
> ##   deletion_propagation_pr_cutoff=float
> ##   plot_poisson=0 or 1
> ##   pdf_output=0 or 1
> 
> ## Returns these values printed out to output log
> ## 
> ##  1. print(nb_fit_size); # 0 if fit failed
> ##  2. print(nb_fit_mu);   # 0 if fit failed
> ##  3. print(m)q
> ##  4. print(v)
> ##  5. print(D)
> ##  6. print(deletion_propagation_coverage)
> ##     -1 if it was <1 after fitting (implying reference sequence is deleted)
> ##
> 
> plot_poisson = 0;
> pdf_output = 1;
> 
> this.print.level = 0
> #this.print.level = 2
> 
> for (e in commandArgs()) {
+   ta = strsplit(e,"=",fixed=TRUE)
+   if(! is.na(ta[[1]][2])) {
+     temp = ta[[1]][2]
+  #   temp = as.numeric(temp) #Im only inputting numbers so I added this to recognize scientific notation
+     if(substr(ta[[1]][1],nchar(ta[[1]][1]),nchar(ta[[1]][1])) == "I") {
+       temp = as.integer(temp)
+     }
+     if(substr(ta[[1]][1],nchar(ta[[1]][1]),nchar(ta[[1]][1])) == "N") {
+       temp = as.numeric(temp)
+     }
+     assign(ta[[1]][1],temp)
+     cat("assigned ",ta[[1]][1]," the value of |",temp,"|\n")
+   } else {
+     assign(ta[[1]][1],TRUE)
+     cat("assigned ",ta[[1]][1]," the value of TRUE\n")
+   }
+ }
assigned  /workspace/home/nasirja/covid-19-signal/.snakemake/conda/1f267c8dfdaa0356ebaad13adc66d00a/lib/R/bin/exec/R  the value of TRUE
assigned  --vanilla  the value of TRUE
assigned  distribution_file  the value of | Plate3BLANK2/breseq/07_error_calibration/0.unique_only_coverage_distribution.tab |
assigned  plot_file  the value of | Plate3BLANK2/breseq/output/calibration/0.unique_coverage.pdf |
assigned  deletion_propagation_pr_cutoff  the value of | 0.000289143 |
> 
> deletion_propagation_pr_cutoff = as.numeric(deletion_propagation_pr_cutoff);
> 
> ## initialize values to be filled in
> nb_fit_mu = 0
> nb_fit_size = 0
> m = 0
> v = 0
> D = 0
> deletion_propagation_coverage = -1
> 
> min_fraction_included_in_nb_fit = 0.01
> 
> #load data
> X<-read.table(distribution_file, header=T)
> 
> #table might be empty
> if (nrow(X) == 0)
+ {
+   #print out statistics
+   
+   print(nb_fit_size);
+   print(nb_fit_mu);
+   
+   print(m)
+   print(v)
+   print(D)
+   
+   print(deletion_propagation_coverage)
+   
+   q()
+ }
> 
> #create the distribution vector and fit
> Y<-rep(X$coverage, X$n)
> m<-mean(Y)
> v<-var(Y)
> D<-v/m
> 
> ###
> ## Smooth the distribution with a moving average window of size 5
> ## so that we can more reliably find it's maximum value
> ###
> 
> ma5 = c(1, 1, 1, 1, 1)/5;
> 
> ## filtering fails if there are too few points
> if (nrow(X) >= 5) {
+   X$ma = filter(X$n, ma5)
+ } else {
+ 	X$ma = X$n
+ }
> 
> i<-0
> max_n <- 0;
> min_i <- max( trunc(m/4), 1 ); #prevents zero for pathological distributions
> max_i <- i;
> for (i in min_i:length(X$ma))
+ {		
+   #cat(i, "\n")
+ 	if (!is.na(X$ma[i]) && (X$ma[i] > max_n))
+ 	{
+ 		max_n = X$ma[i];
+ 		max_i = i;
+ 	}
+ }
> 
> ##
> # Censor data on the right and left of the maximum
> ##
> 
> start_i = max(floor(max_i*0.5), 1);
> end_i = min(ceiling(max_i*1.5), length(X$ma));
> 
> if (start_i == end_i)
+ {
+   print(nb_fit_size);
+   print(nb_fit_mu);
+   
+   print(m)
+   print(v)
+   print(D)
+   
+   print(deletion_propagation_coverage)
+   
+   q()
+ }
> 
> cat("Fitting from coverage of ", start_i, " to ", end_i, ".\n", sep="")
Fitting from coverage of 1 to 5.
> 
> ##
> # Coarse grain so that we are only fitting a number of bins that is 1000-2000
> #
> # The later adjustment for doing the fits this way is to multiply the means
> # of the negative binomial and poisson distributions by the binning number.
> # (The size parameter of the negative binomial doesn't need to be adjusted.)
> ##
> 
> 
> num_per_bin = trunc((end_i - start_i) / 1000)
> 
> if (num_per_bin > 1) 
+ {
+   cat("Coarse-graining for fits\n")
+   start_i_for_fits = trunc(start_i/num_per_bin)
+   end_i_for_fits = ceiling(end_i/num_per_bin)
+   num_bins = end_i - start_i  + 1
+   cat("Fitting from coverage in adjusted bins ", start_i_for_fits, " to ", end_i_for_fits, ".\n", sep="")
+   cat("Number of bins ", num_bins, ". Each bin has ", num_per_bin, " coverage values.\n", sep="")
+ 
+   # Create a new vector where we've added together values in bins
+   X.for.fits = vector("double", end_i_for_fits)
+   for (i in start_i_for_fits:end_i_for_fits)
+   {
+     for (j in 1:num_per_bin)
+     {
+       if (i*num_per_bin+j <= length(X$n))
+       {
+         X.for.fits[i] = X.for.fits[i] + X$n[i*num_per_bin+j]
+       }
+     }
+   }
+ 
+ } else {
+   ## AVOID num_per_bin equalling zero!!
+   X.for.fits = X$n[1:end_i]
+   num_per_bin = 1
+   start_i_for_fits = start_i
+   end_i_for_fits = end_i
+ }
> 
> 
> ##
> # Now perform negative binomial fitting to the censored data
> ##
> 
> inner_total<-0;
> for (i in start_i_for_fits:end_i_for_fits)
+ {
+ 	inner_total = inner_total + X.for.fits[i]; 
+ }
> # Yes: it's correct to use X here because we want the overall total total
> total_total<-sum(X$n);
> 
> ## let's preconstruct these for speed
> dist = vector("double", end_i_for_fits)
> 
> f_nb <- function(par) {
+ 
+ 	mu = par[1];
+ 	size = par[2];
+ 
+   if ((mu <= 0) || (size <= 0))
+   {
+     return(0);
+   }
+   
+   cat(start_i_for_fits, " ", end_i_for_fits, "\n");
+   cat(mu, " ", size, "\n");
+   
+ 	dist<-c()
+ 	total <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{	
+ 		dist[i] <- dnbinom(i, size=size, mu=mu);
+ 		total <- total + dist[i] 
+ 	}
+ 	#print (mu, size)
+ 
+  	l <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{
+ 		l <- l + ((X.for.fits[i]/inner_total)-(dist[i]/total))^2;
+ 	}
+ 	return(l);
+ }
> 
> 
> 
> ## Fit negative binomial 
> ## - allow fit to fail and set all params to zero/empty if that is the case
> nb_fit = NULL
> ## as.numeric prevents overflow in sums involving integers
> mean_estimate = sum((as.numeric(1:end_i_for_fits)*as.numeric(X.for.fits)))/sum(as.numeric(X.for.fits))
> 
> nb_fit_mu = -1
> nb_fit_size = -1
> try_size = 100000
> try_means_index = 1
> #This is a list of different means to test <-  sometimes the actual mean doesn't lead to a fit
> try_means = c(mean_estimate, 
+               end_i_for_fits, 
+               start_i_for_fits, 
+               1*(end_i_for_fits + start_i_for_fits)/4,
+               2*(end_i_for_fits + start_i_for_fits)/4,
+               3*(end_i_for_fits + start_i_for_fits)/4
+               )
>               
>               
> nb_fit = c()
> 
> while ( ((nb_fit_mu < 0) || (nb_fit_size < 0) || (nb_fit$code != 1)) && (try_size > 0.001) && (try_means_index <= length(try_means)))
+ {
+   try_size = try_size / 10
+   try_mean = try_means[try_means_index]
+ 
+   ## SIZE ESTIMATE from the censored data can be negative, so try various values instead
+   cat("Try Mean: ", try_mean, " Size: ", try_size, "\n")
+ 
+   try( suppressWarnings(nb_fit<-nlm(f_nb, c(try_mean, try_size), iterlim=1000, print.level=this.print.level)) )
+ 
+   nb_fit_mu = nb_fit$estimate[1];
+   nb_fit_size = nb_fit$estimate[2];
+ 
+   cat("Fit Mean: ", nb_fit_mu, " Size: ", nb_fit_size, " Code: ", nb_fit$code, "\n")
+   
+   if (try_size <= 0.001) {
+     try_size = 100000
+     try_means_index = try_means_index + 1
+   }
+ }
Try Mean:  1.57978  Size:  10000 
1   5 
1.57978   10000 
1   5 
1.57978   10000 
1   5 
1.579781   10000 
1   5 
1.57978   10000.01 
1   5 
1.475234   10000 
1   5 
1.475235   10000 
1   5 
1.475234   10000.01 
1   5 
0.8371851   10000 
1   5 
0.8371861   10000 
1   5 
0.8371851   10000.01 
1   5 
1.153606   10000 
1   5 
1.153608   10000 
1   5 
1.153606   10000.01 
1   5 
1.089171   10000 
1   5 
1.089172   10000 
1   5 
1.089171   10000.01 
1   5 
1.074416   10000 
1   5 
1.074418   10000 
1   5 
1.074416   10000.01 
1   5 
1.075314   10000 
1   5 
1.075315   10000 
1   5 
1.075314   10000.01 
1   5 
1.075304   10000 
1   5 
1.075305   10000 
1   5 
1.075304   10000.01 
1   5 
1.075304   10000 
1   5 
1.075305   10000 
1   5 
1.075304   10000.01 
Fit Mean:  1.075304  Size:  10000  Code:  2 
Try Mean:  1.57978  Size:  1000 
1   5 
1.57978   1000 
1   5 
1.57978   1000 
1   5 
1.579781   1000 
1   5 
1.57978   1000.001 
1   5 
1.475348   1000 
1   5 
1.47535   1000 
1   5 
1.475348   1000.001 
1   5 
0.8358686   1000 
1   5 
0.8358696   1000 
1   5 
0.8358686   1000.001 
1   5 
1.153852   1000 
1   5 
1.153853   1000 
1   5 
1.153852   1000.001 
1   5 
1.089056   1000 
1   5 
1.089057   1000 
1   5 
1.089056   1000.001 
1   5 
1.074104   1000 
1   5 
1.074105   1000 
1   5 
1.074104   1000.001 
1   5 
1.075021   1000 
1   5 
1.075022   1000 
1   5 
1.075021   1000.001 
1   5 
1.075011   1000 
1   5 
1.075012   1000 
1   5 
1.075011   1000.001 
1   5 
1.075011   1000 
1   5 
1.075012   1000 
1   5 
1.075011   1000.001 
Fit Mean:  1.075011  Size:  1000  Code:  2 
Try Mean:  1.57978  Size:  100 
1   5 
1.57978   100 
1   5 
1.57978   100 
1   5 
1.579781   100 
1   5 
1.57978   100.0001 
1   5 
1.476473   100 
1   5 
1.476475   100 
1   5 
1.476473   100.0001 
1   5 
0.8225407   100.0001 
1   5 
0.8225417   100.0001 
1   5 
0.8225407   100.0002 
1   5 
1.156437   100 
1   5 
1.156438   100 
1   5 
1.156437   100.0001 
1   5 
1.088011   100.0001 
1   5 
1.088012   100.0001 
1   5 
1.088011   100.0002 
1   5 
1.070953   100.0001 
1   5 
1.070954   100.0001 
1   5 
1.070953   100.0002 
1   5 
1.072093   100.0001 
1   5 
1.072094   100.0001 
1   5 
1.072093   100.0002 
1   5 
1.072079   100.0001 
1   5 
1.07208   100.0001 
1   5 
1.072079   100.0002 
1   5 
1.072075   100.0001 
1   5 
1.072076   100.0001 
1   5 
1.072075   100.0002 
1   5 
1.072056   100.0003 
1   5 
1.072057   100.0003 
1   5 
1.072056   100.0004 
1   5 
1.072033   100.0007 
1   5 
1.072034   100.0007 
1   5 
1.072033   100.0008 
1   5 
1.071992   100.0019 
1   5 
1.071993   100.0019 
1   5 
1.071992   100.002 
1   5 
1.071928   100.005 
1   5 
1.071929   100.005 
1   5 
1.071928   100.0051 
1   5 
1.071822   100.0137 
1   5 
1.071823   100.0137 
1   5 
1.071822   100.0138 
1   5 
1.071653   100.0365 
1   5 
1.071654   100.0365 
1   5 
1.071653   100.0366 
1   5 
1.07138   100.0971 
1   5 
1.071381   100.0971 
1   5 
1.07138   100.0972 
1   5 
1.070943   100.2563 
1   5 
1.070944   100.2563 
1   5 
1.070943   100.2564 
1   5 
1.070249   100.6721 
1   5 
1.07025   100.6721 
1   5 
1.070249   100.6722 
1   5 
1.069175   101.7466 
1   5 
1.069176   101.7466 
1   5 
1.069175   101.7467 
1   5 
1.067604   104.4606 
1   5 
1.067605   104.4606 
1   5 
1.067604   104.4607 
1   5 
1.065592   111.008 
1   5 
1.065593   111.008 
1   5 
1.065592   111.0081 
1   5 
1.063738   125.7166 
1   5 
1.063739   125.7166 
1   5 
1.063738   125.7168 
1   5 
1.063574   156.3207 
1   5 
1.063575   156.3207 
1   5 
1.063574   156.3209 
1   5 
1.067148   212.6837 
1   5 
1.067149   212.6837 
1   5 
1.067148   212.6839 
1   5 
1.07307   288.7931 
1   5 
1.073071   288.7931 
1   5 
1.07307   288.7934 
1   5 
1.07683   357.6186 
1   5 
1.076831   357.6186 
1   5 
1.07683   357.619 
1   5 
1.078438   424.4574 
1   5 
1.078439   424.4574 
1   5 
1.078438   424.4579 
1   5 
1.078878   535.1927 
1   5 
1.078879   535.1927 
1   5 
1.078878   535.1932 
1   5 
1.077625   710.6689 
1   5 
1.077626   710.6689 
1   5 
1.077625   710.6696 
1   5 
1.075525   942.5868 
1   5 
1.075526   942.5868 
1   5 
1.075525   942.5877 
1   5 
1.074127   1196.428 
1   5 
1.074128   1196.428 
1   5 
1.074127   1196.429 
1   5 
1.073579   1508.986 
1   5 
1.07358   1508.986 
1   5 
1.073579   1508.988 
1   5 
1.0738   1980.375 
1   5 
1.073801   1980.375 
1   5 
1.0738   1980.377 
1   5 
1.074645   2651.985 
1   5 
1.074646   2651.985 
1   5 
1.074645   2651.988 
1   5 
1.075481   3474.807 
1   5 
1.075482   3474.807 
1   5 
1.075481   3474.81 
1   5 
1.07594   4450.652 
1   5 
1.075941   4450.652 
1   5 
1.07594   4450.656 
1   5 
1.07602   5782.845 
1   5 
1.076021   5782.845 
1   5 
1.07602   5782.851 
1   5 
1.075758   7683.894 
1   5 
1.075759   7683.894 
1   5 
1.075758   7683.902 
1   5 
1.075364   10194.41 
1   5 
1.075365   10194.41 
1   5 
1.075364   10194.42 
1   5 
1.07509   13214.34 
1   5 
1.075091   13214.34 
1   5 
1.07509   13214.35 
1   5 
1.074991   17217.77 
1   5 
1.074992   17217.77 
1   5 
1.074991   17217.79 
1   5 
1.075062   22972.08 
1   5 
1.075063   22972.08 
1   5 
1.075062   22972.11 
1   5 
1.075232   29871.47 
1   5 
1.075233   29871.47 
1   5 
1.075232   29871.5 
1   5 
1.075396   38892.82 
1   5 
1.075397   38892.82 
1   5 
1.075396   38892.86 
1   5 
1.075525   54396.36 
1   5 
1.075526   54396.36 
1   5 
1.075525   54396.42 
1   5 
1.075497   66395.88 
1   5 
1.075498   66395.88 
1   5 
1.075497   66395.94 
1   5 
1.075372   106490 
1   5 
1.075373   106490 
1   5 
1.075372   106490.1 
1   5 
1.075265   161040.7 
1   5 
1.075266   161040.7 
1   5 
1.075265   161040.9 
1   5 
1.075277   179783.6 
1   5 
1.075278   179783.6 
1   5 
1.075277   179783.8 
1   5 
1.075278   204218.9 
1   5 
1.075279   204218.9 
1   5 
1.075278   204219.1 
1   5 
1.075305   207160.9 
1   5 
1.075306   207160.9 
1   5 
1.075305   207161.1 
1   5 
1.07532   230614.8 
1   5 
1.075321   230614.8 
1   5 
1.07532   230615 
1   5 
1.075327   230876.9 
1   5 
1.075328   230876.9 
1   5 
1.075327   230877.1 
1   5 
1.075345   272270.5 
1   5 
1.075346   272270.5 
1   5 
1.075345   272270.7 
1   5 
1.075343   281613.2 
1   5 
1.075344   281613.2 
1   5 
1.075343   281613.5 
1   5 
1.07534   275640 
1   5 
1.075342   279658.8 
1   5 
1.075343   281073.7 
1   5 
1.075343   281459.8 
1   5 
1.075343   281569.6 
1   5 
1.075343   281600.9 
1   5 
1.075343   281609.6 
1   5 
1.075343   281612.2 
1   5 
1.075343   281613 
1   5 
1.07545   281613.2 
1   5 
1.075235   281613.2 
1   5 
1.075343   281641.4 
1   5 
1.075343   281585 
1   5 
1.075339   284679 
1   5 
1.075447   284679 
1   5 
1.075232   284679 
1   5 
1.075339   284707.5 
1   5 
1.075339   284650.5 
Fit Mean:  1.075339  Size:  284679  Code:  1 
> 
> cat("Final Fit Mean: ", nb_fit_mu, " Size: ", nb_fit_size, " Code: ", nb_fit$code, " Try Size: ", try_size, "\n")
Final Fit Mean:  1.075339  Size:  284679  Code:  1  Try Size:  100 
> 
> ## Fit failed = reset parameters so graphing and output code can recognize this
> if ((nb_fit_mu < 0) || (nb_fit_size < 0) || (nb_fit$code != 1))
+ {
+   nb_fit_mu = 0
+   nb_fit_size = 0
+ }
> 
> 
> ## things can go wrong with fitting and we can still end up with invalid values
> 
> fit_nb = c()
> included_fract = 0
> if (nb_fit_mu > 0)
+ {
+   end_fract = pnbinom(end_i_for_fits, mu = nb_fit_mu, size=nb_fit_size)
+   start_fract = pnbinom(start_i_for_fits, mu = nb_fit_mu, size=nb_fit_size)
+   included_fract = end_fract-start_fract;
+ 
+   if (included_fract >= 0.01) {
+ 
+     ## Adjust so that we are back in full coords before making fit!!
+     if (num_per_bin > 1) 
+     {
+       nb_fit_mu = nb_fit_mu * num_per_bin
+     }
+     fit_nb = dnbinom(0:max(X$coverage), mu = nb_fit_mu, size=nb_fit_size)*inner_total/included_fract;
+   }
+ }
> 
> ## If an insufficient amount of fit was included, then invalidate it
> if (included_fract < 0.01)
+ {
+   nb_fit_mu = 0
+   nb_fit_size = 0
+ }
> 
> f_p <- function(par) {
+ 
+   lambda = par[1];
+ 
+   if (lambda <= 0)
+   {
+     return(0);
+   }
+   
+ 	total <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{	
+     #cat(i, " ", lambda, "\n");
+ 		dist[i] <- dpois(i, lambda=lambda);
+ 		total <- total + dist[i] 
+ 	}
+ 	#print (total)
+ 
+  	l <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{
+ 		l <- l + ((X.for.fits[i]/inner_total)-(dist[i]/total))^2;
+ 	}
+ 	return(l);
+ }
> 
> 
> ## Fit Poisson 
> ## - allow fit to fail and set all params to zero/empty if that is the case
> 
> p_fit = NULL
> try(suppressWarnings(p_fit<-nlm(f_p, c(m), print.level=this.print.level)))
> 
> fit_p = c()
> if (!is.null(p_fit) && (p_fit$estimate[1] > 0))
+ {
+   #print (nb_fit$estimate[1])
+   p_fit_lambda = p_fit$estimate[1];
+   #print(0:max(X$coverage))
+ 
+   end_fract = ppois(end_i_for_fits, lambda = p_fit_lambda)
+   start_fract = ppois(start_i_for_fits, lambda = p_fit_lambda)
+   included_fract = end_fract-start_fract;
+ 
+   ## Adjust so that we are back in full coords before making fit!!
+   if (num_per_bin > 1) 
+   {
+     p_fit_lambda = p_fit_lambda * num_per_bin
+   }
+   fit_p<-dpois(0:max(X$coverage), lambda = p_fit_lambda)*inner_total/included_fract;
+ }
> 
> 
> ## Graphing
> ##
> ## don't graph very high values with very little coverage
> i<-max_i
> while (i <= length(X$n) && X$n[i]>0.01*max_n)
+ {		
+ 	i <- i+1;
+ }
> graph_end_i <-i
> 
> ## Ths leaves enough room to the right of the peak for the legend
> graph_end_i = max(floor(2.2 * max_i), graph_end_i);
> 
> ## graphics settings
> my_pch = 21
> my_col = "black";
> my_col_censored = "red";
> 
> if (pdf_output == 0) {
+   
+   ## bitmap() requires ghostscript to be installed.
+   ## taa=4, gaa=2 options NOT compatible with earlier R versions!
+   ## units = "px" NOT compatible with even earlier R versions!
+   
+   if(!capabilities(what = "png"))
+   {
+     ## fallback to ghostscript
+     bitmap(plot_file, height=6, width=7, type = "png16m", res = 72, pointsize=18)
+   } else {
+     ## use X11 function, which gives better resolution
+     png(plot_file, height=6, width=7, units ="in", res = 72, pointsize=18)
+     par(family="sans")
+   }
+ } else {
+   pdf(plot_file, height=6, width=7)
+   par(family="sans")
+ }
> 
> par(mar=c(5.5,7.5,3,1.5));
> 
> max_y = 0
> if (plot_poisson) {
+ 	max_y = max(X$n, fit_p, fit_nb)
+ } else {
+ 	max_y = max(X$n, fit_nb)
+ }
> 
> plot(0:10, 0:10, type="n", lty="solid", ylim=c(0, max_y)*1.05, xlim=c(0, graph_end_i), lwd=1, xaxs="i", yaxs="i", axes=F, las=1, main="Coverage Distribution at Unique-Only Positions", xlab="Coverage depth (reads)", ylab="", cex.lab=1.2, cex.axis=1.2)
> 
> mtext(side = 2, text = "Number of reference positions", line = 5.5, cex=1.2)
> 
> sciNotation <- function(x, digits = 1) {
+     if (length(x) > 1) {
+         return(append(sciNotation(x[1]), sciNotation(x[-1])))     
+ 	} 
+     if (!x) return(0) 
+ 
+ 	exponent <- floor(log10(x)) 
+     base <- round(x / 10^exponent, digits)     
+ 	as.expression(substitute(base %*% 10^exponent, list(base = base, exponent = exponent))) 
+ }
> 
> #axis(2, cex.lab=1.2, las=1, cex.axis=1.2, labels=T, at=(0:6)*50000)
> axis(2, cex.lab=1.2, las=1, cex.axis=1.2, at = axTicks(2), labels = sciNotation(axTicks(2), 1))
> axis(1, cex.lab=1.2, cex.axis=1.2, labels=T)
> box()
> 
> #graph the coverage as points
> fit_data <- subset(X, (coverage>=start_i) & (coverage<=end_i) );
> points(fit_data$coverage, fit_data$n, pch=my_pch, col=my_col, bg="white", cex=1.2)
> 
> #graph the censored coverage as red points
> cat(start_i, " ", end_i, "\n", sep="")
1 5
> 
> censored_data <- subset(X, (coverage<start_i) | (coverage>end_i) );
> points(censored_data$coverage, censored_data$n, pch=my_pch, col=my_col_censored, bg="white", cex=1.2)
> 
> #graph the poisson fit IF REQUESTED
> if (plot_poisson) {
+ 	lines(0:max(X$coverage), fit_p, lwd=3, lty="22", col="black");
+ }
> 
> #graph the negative binomial fit
> if (nb_fit_mu > 0) {
+   lines(0:max(X$coverage), fit_nb, lwd=3, col="black");
+ }
> 
> if (plot_poisson) {
+ 	legend("topright", c("Coverage distribution", "Censored data", "Negative binomial", "Poisson"), lty=c("blank","blank","solid","22"), lwd=c(1,1,2,2), pch=c(my_pch, my_pch, -1, -1), col=c("black", "red", "black", "black"), bty="n")
+ } else {
+ 	legend("topright", c("Coverage distribution", "Censored data", "Negative binomial"), lty=c("blank","blank","solid"), lwd=c(1,1,2), pch=c(my_pch, my_pch, -1), col=c("black", "red", "black"), bty="n")
+ }
> 
> dev.off()
null device 
          1 
> 
> ## Fit the marginal value that we use for propagating deletions
> 
> if (nb_fit_mu > 0) {
+   cat(nb_fit_size, " ", nb_fit_mu, "\n")
+   deletion_propagation_coverage = suppressWarnings(qnbinom(deletion_propagation_pr_cutoff, size = nb_fit_size, mu = nb_fit_mu))
+ } else {
+   cat("Fallback to calculating off an estimate of just variance = mu + mu^2/size\n")
+   size_estimate = (1/(v-m))*(m*m)
+   cat("Mu estimate=", m," Size estimate =", size_estimate, "\n")
+   deletion_propagation_coverage = suppressWarnings(qnbinom(deletion_propagation_pr_cutoff, size = size_estimate, mu = m))
+   if (is.na(deletion_propagation_coverage) || is.nan(deletion_propagation_coverage) || (deletion_propagation_coverage < 1)) {
+     cat("Double fallback to calculating as just 10% of the mean\n")
+     deletion_propagation_coverage = m * 0.1
+   }
+ }
284679   1.075339 
> 
> #Don't allow one read to indicate non-deleted regions
> if (deletion_propagation_coverage < 1) {
+     deletion_propagation_coverage = 1
+ }
> 
> #This works fine with the negative values
> #If we have both low fit coverage and low straight average coverage then we're deleted...
> if ( (nb_fit_mu <= 3) && (m <= 3) ) {
+   deletion_propagation_coverage = -1
+ }
> 
> #print out statistics
> 
> print(nb_fit_size);
[1] 284679
> print(nb_fit_mu);
[1] 1.075339
> 
> print(m)
[1] 8.957347
> print(v)
[1] 1085.273
> print(D)
[1] 121.1601
> 
> print(deletion_propagation_coverage)
[1] 1
> 
> warnings()
> 
