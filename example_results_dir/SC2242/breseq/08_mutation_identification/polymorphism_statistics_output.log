ARGUMENT 'total_length=29903' __ignored__

ARGUMENT 'in_file=SC2242/breseq/08_mutation_identification/polymorphism_statistics_input.tab' __ignored__

ARGUMENT 'out_file=SC2242/breseq/08_mutation_identification/polymorphism_statistics_output.tab' __ignored__

ARGUMENT 'qual_file=SC2242/breseq/08_mutation_identification/error_counts.tab' __ignored__


R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-conda_cos6-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##
> ##
> ## AUTHORS
> ##
> ## Jeffrey E. Barrick <jeffrey.e.barrick@gmail.com>
> ##
> ## LICENSE AND COPYRIGHT
> ##
> ## Copyright (c) 2008-2010 Michigan State University
> ## Copyright (c) 2011-2017 The University of Texas at Austin
> ##
> ## breseq is free software; you can redistribute it and/or modify it under the
> ## terms the GNU General Public License as published by the Free Software
> ## Foundation; either version 1, or (at your option) any later version.
> ##
> ##
> 
> ## Args should be in_file=/path/to/input out_file=/path/to/output total_length=<total_length_of_sequences>  qual_file=
> 
> ##error_count_file=/path/to/error_count
> 
> for (e in commandArgs()) {
+   ta = strsplit(e,"=",fixed=TRUE)
+   if(! is.na(ta[[1]][2])) {
+     temp = ta[[1]][2]
+  #   temp = as.numeric(temp) #Im only inputting numbers so I added this to recognize scientific notation
+     if(substr(ta[[1]][1],nchar(ta[[1]][1]),nchar(ta[[1]][1])) == "I") {
+       temp = as.integer(temp)
+     }
+     if(substr(ta[[1]][1],nchar(ta[[1]][1]),nchar(ta[[1]][1])) == "N") {
+       temp = as.numeric(temp)
+     }
+     assign(ta[[1]][1],temp)
+     cat("assigned ",ta[[1]][1]," the value of |",temp,"|\n")
+   } else {
+     assign(ta[[1]][1],TRUE)
+     cat("assigned ",ta[[1]][1]," the value of TRUE\n")
+   }
+ }
assigned  /workspace/home/nasirja/covid-19-signal/.snakemake/conda/1f267c8dfdaa0356ebaad13adc66d00a/lib/R/bin/exec/R  the value of TRUE
assigned  --vanilla  the value of TRUE
assigned  total_length  the value of | 29903 |
assigned  in_file  the value of | SC2242/breseq/08_mutation_identification/polymorphism_statistics_input.tab |
assigned  out_file  the value of | SC2242/breseq/08_mutation_identification/polymorphism_statistics_output.tab |
assigned  qual_file  the value of | SC2242/breseq/08_mutation_identification/error_counts.tab |
> 
> 
> total_length = as.numeric(total_length);
> 
> 
> X<-read.table(in_file, sep="\t", header=T)
> #print(X)
> 
> ##allocate output data frame
> Y<-data.frame(
+   ks_quality_p_value = 1:length(X$major_frequency)
+ );
> 
> qual_dist<-read.table(qual_file, sep="\t", header=F)
> print(qual_dist)
        V1
1        0
2        0
3        0
4        0
5        0
6        0
7        0
8        0
9        0
10     552
11  222208
12  849016
13 3380953
14 2761222
15 1796382
16 3936636
17       0
18     126
19     644
20   72714
21  891081
22  623809
23 1190493
24  426984
25  548970
26  274096
27 4327577
28  486947
29   69638
30 3981602
31 4708209
32 1954015
33 2642422
34 1597646
35 4361039
36   22028
37 1635717
38   30337
39  135130
40  195524
> qual_dist<-as.vector(qual_dist$V1);
> 
> qual_dist = ceiling(qual_dist / 1000)
> 
> print(qual_dist)
 [1]    0    0    0    0    0    0    0    0    0    1  223  850 3381 2762 1797
[16] 3937    0    1    1   73  892  624 1191  427  549  275 4328  487   70 3982
[31] 4709 1955 2643 1598 4362   23 1636   31  136  196
> 
> 
> qual_dist_list = c();
> for (i in 1:length(qual_dist))
+ {
+ 	qual_dist_list = c(qual_dist_list, rep(i, qual_dist[i]));
+ }
> 
> qual_dist = qual_dist / sum(qual_dist)
> qual_cdf = c();
> 
> pr_sum = 0;
> for (i in 1:length(qual_dist))
+ {
+ 	pr_sum = pr_sum + qual_dist[i];
+ 	qual_cdf[i] = pr_sum;		
+ }
> 
> 
> print(qual_cdf)
 [1] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00
 [6] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 2.318034e-05
[11] 5.192397e-03 2.489569e-02 1.032684e-01 1.672925e-01 2.089476e-01
[16] 3.002086e-01 3.002086e-01 3.002318e-01 3.002550e-01 3.019471e-01
[21] 3.226240e-01 3.370885e-01 3.646963e-01 3.745943e-01 3.873204e-01
[26] 3.936949e-01 4.940195e-01 5.053083e-01 5.069309e-01 5.992350e-01
[31] 7.083913e-01 7.537089e-01 8.149745e-01 8.520167e-01 9.531293e-01
[36] 9.536625e-01 9.915855e-01 9.923041e-01 9.954567e-01 1.000000e+00
> 
> qual_pr <- function(qual_cdf = qual_cdf)
+ {
+ 	if (x > length(qual_cdf))
+ 	{
+ 		return(1)
+ 	}
+ 	return (qual_cdf[trunc(x)]);
+ }
> 
> #print(Y)
> 
> if (length(X$major_quals) > 0)
+ {
+ 	for (i in 1:length(X$major_quals))
+ 	{
+ 		#print (i);
+     major_quals_list = c()
+     major_quals = c()
+     #cat(i, " length: ", length(X$major_quals[i]), "\n")
+     if (length(X$major_quals[i]) > 0) {
+       major_quals_list <- strsplit(as.character(X$major_quals[i]), ",");
+       major_quals <- as.numeric( major_quals_list[[1]] )
+     }
+     
+     minor_quals_list = c()
+     minor_quals = c()
+     
+     #cat(i, " length: ", length(X$minor_quals[i]), "\n")
+     if (length(X$minor_quals[i]) > 0) {
+       minor_quals_list <- strsplit(as.character(X$minor_quals[i]), ",");
+       minor_quals <- as.numeric( minor_quals_list[[1]] )
+     }
+ 
+     ##cat("\n")
+     ##print(minor_quals)
+         
+     ## This code estimates the actual strand and quality score distribution as the total observed.
+ #		max_qual = max(major_quals, minor_quals)
+ #		NQ = tabulate(major_quals, nbins=max_qual)
+ #		RQ = tabulate(minor_quals, nbins=max_qual)
+ #		TQ = NQ+RQ
+ #
+ #		log10_qual_likelihood = log10(dmultinom(NQ, prob=TQ)) + log10(dmultinom(RQ, prob=TQ)) - log10(dmultinom(TQ, prob=TQ))
+ #		Y$log10_qual_likelihood_position_model[i] = -log10_qual_likelihood
+ 		
+ #		RS = c(X$major_top_strand[i], X$major_bot_strand[i])
+ #		NS = c(X$minor_top_strand[i], X$minor_bot_strand[i])
+ #		TS = RS+NS
+ 		
+ #		log10_strand_likelihood =  log10(dmultinom(RS, prob=TS)) + log10(dmultinom(NS, prob=TS)) - log10(dmultinom(TS, prob=TS))
+ #		Y$log10_strand_likelihood_position_model[i] = -log10_strand_likelihood
+ 
+ 		#likelihoods are written as NULL model (one base) versus POLYMORPHISM model (mixed bases)
+ 		#log10_base_likelihood should be negative
+ 		#log10_qual_likelihood should be positive
+ 		#log10_strand_likelihood should be positive
+ 
+ 		#convert to natural logarithm and back to log10
+     #score_combined_log =  -2* ( Y$log10_base_likelihood[i]  + Y$log10_qual_likelihood_position_model[i] + Y$log10_strand_likelihood_position_model[i]) * log(10)
+     #Y$quality_position_model[i] = -pchisq(score_combined_log, 1, lower.tail=T, log=T) / log(10)
+ 		
+ 	## This section estimates the actual strand distribution as the reference observations and the quality score distribution from the
+ 	## count across the entire genome for all bases added together (doesn't take into account that there may be more low G's than A's, for example)	
+ 
+ #		max_qual = length(qual_dist)
+ #		NQ = tabulate(best_quals, nbins=max_qual)
+ #		RQ = tabulate(second_best_quals, nbins=max_qual)
+ #		TQ = NQ+RQ
+ #		EQ = RQ+1
+ 						
+ #		log10_qual_likelihood_genome_mode = log10(dmultinom(NQ, prob=EQ)) + log10(dmultinom(RQ, prob=EQ)) - log10(dmultinom(TQ, prob=TQ))
+ #		Y$log10_qual_likelihood_genome_model[i] = -log10_qual_likelihood_genome_mode
+ 
+ #		RS = c(X$ref_top_strand[i], X$ref_bot_strand[i])
+ #		NS = c(X$new_top_strand[i], X$new_bot_strand[i])
+ #		TS = RS + NS
+ 		
+ #		log10_strand_likelihood_genome_mode =  log10(dmultinom(TS, prob=TS+1)) - log10(dmultinom(RS, prob=RS+1)) + log10(dmultinom(NS, prob=RS+1))
+ #		Y$log10_strand_likelihood_genome_model[i] = -log10_strand_likelihood_genome_mode
+ 
+ #		#convert to natural logarithm and back to 
+ #		score_combined_log_genome_mode =  -2 * ( Y$log10_base_likelihood[i] + Y$log10_strand_likelihood_genome_model[i]) * log(10)
+ 
+ #		Y$quality_genome_model[i] = -pchisq(score_combined_log_genome_mode, 1, lower.tail=T, log=T) / log(10)
+ #		score_combined_log_genome_mode =  -2 * ( Y$log10_base_likelihood[i]) * log(10)
+ 		
+ 
+ 		## KS test for unusual qualities -- Rewrite to use cumulative distribution! = faster and more accurate
+ 		all_quals = c(minor_quals,major_quals);
+ 
+ 		options(warn=-1);
+ 
+ 		if (X$major_frequency[i] < 0.5)
+ 		{
+ 			poly_quals = major_quals;
+ 		}
+ 		else
+ 		{
+ 			poly_quals = minor_quals;
+ 		}
+ 
+ ## This one tests the quality scores predicting a polymorphism agains the overall distribution
+ ## at all positions in the genome	
+ #	ks_test_p_value_unusual <- ks.test(qual_dist_list, poly_quals, alternative = "less")
+ #	ks_test_p_value_unusual <- ks_test_p_value_unusual$p.value
+ #	Y$ks_quality_p_value_unusual_poly[i] <- ks_test_p_value_unusual
+ 
+ 
+ #	ks_test_p_value_unusual <- ks.test(qual_dist_list, second_best_quals, alternative = "less")
+ #	ks_test_p_value_unusual <- ks_test_p_value_unusual$p.value
+ #	Y$ks_quality_p_value_unusual_ref[i] <- ks_test_p_value_unusual
+ 	
+ #	ks_test_p_value_unusual <- ks.test(qual_dist_list, best_quals, alternative = "less")
+ #	ks_test_p_value_unusual <- ks_test_p_value_unusual$p.value
+ #	Y$ks_quality_p_value_unusual_new[i] <- ks_test_p_value_unusual
+ 
+ #	ks_test_p_value_unusual <- ks.test(qual_dist_list, all_quals, alternative = "less")
+ #	ks_test_p_value_unusual <- ks_test_p_value_unusual$p.value
+ #	Y$ks_quality_p_value_unusual_all[i] <- ks_test_p_value_unusual
+ 
+ 	## Oldest code that calculates bias p-values
+ 	
+     options(warn=-1);
+     
+     ks_test_p_value = 1
+     if ((length(minor_quals) > 0) && (length(major_quals) > 0)) {
+       ks_test_result <- ks.test(minor_quals, major_quals, alternative = "less")
+       ks_test_p_value <- ks_test_result$p.value
+     }
+     options(warn=0);
+     
+ 		Y$ks_quality_p_value[i] <- ks_test_p_value
+ 
+ 		contingency_table <- matrix(data=c(X$minor_top_strand[i], X$minor_bot_strand[i], X$major_top_strand[i], X$major_bot_strand[i]), nrow=2, ncol=2)
+ 		#print(contingency_table)
+ 	
+ 		fisher_test_p_value <- fisher.test( contingency_table, alternative="two.sided")
+ 		fisher_test_p_value <- fisher_test_p_value$p.value
+ 		#print(fisher_test_p_value)
+ 	
+ 		Y$fisher_strand_p_value[i] <- fisher_test_p_value
+ 	
+ 		# Fisher's method for combining p-values
+ 		combined_log = - 2* ( log(ks_test_p_value) + log(fisher_test_p_value) )
+ 		Y$bias_p_value[i] = pchisq(combined_log, 2*2, lower.tail=F)
+ 	
+ 		Y$bias_e_value[i] = Y$bias_p_value[i] * total_length
+ 	}
+ }
> 
> Y = signif(Y, digits = 6)
> write.table(Y, out_file, sep="\t", row.names=F, quote=F)
> 
